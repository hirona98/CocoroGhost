"""Generate a single plain-text third-party licenses file.

This script converts the JSON output produced by `pip-licenses` into a single
human-readable plain text file suitable for bundling with external distributions.

Expected input JSON is generated by:
    python -m piplicenses --format=json --with-urls --with-license-file --with-notice-file

Outputs a consolidated text file containing:
- Package name/version
- Declared license string
- Project URL
- License file path and full license text
- NOTICE file path and full notice text (when present)
"""

from __future__ import annotations

import argparse
import json
from datetime import datetime
from pathlib import Path
from typing import Any


def _parse_args() -> argparse.Namespace:
    """Parse command-line arguments."""

    # CLI: keep defaults aligned with current repo conventions.
    parser = argparse.ArgumentParser(description="Generate consolidated OSS licenses text.")
    parser.add_argument(
        "--input",
        type=Path,
        default=Path("docs/THIRD_PARTY_LICENSES.json"),
        help="Path to pip-licenses JSON output.",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("docs/THIRD_PARTY_LICENSES.txt"),
        help="Path to write consolidated plain text notices.",
    )
    parser.add_argument(
        "--exclude",
        nargs="*",
        default=["cocoro-ghost"],
        help="Package names to exclude (case-insensitive). Default: cocoro-ghost",
    )
    return parser.parse_args()


def _should_include_package(name: str, excluded_names: set[str]) -> bool:
    """Return True if the package should be included in output."""

    # Filtering: treat excluded names case-insensitively.
    normalized = name.strip().casefold()
    if not normalized:
        return True
    return normalized not in excluded_names


def _load_packages(input_path: Path) -> list[dict[str, Any]]:
    """Load package entries from a pip-licenses JSON file."""

    # IO: read the full JSON content.
    raw = input_path.read_text(encoding="utf-8")
    data = json.loads(raw)

    if not isinstance(data, list):
        raise ValueError("pip-licenses JSON must be a list of objects")

    # Validation: keep only dict-like items.
    packages: list[dict[str, Any]] = []
    for item in data:
        if isinstance(item, dict):
            packages.append(item)
    return packages


def _as_text(value: Any) -> str:
    """Convert a JSON field into safe display text."""

    # Normalization: preserve strings, stringify other scalars.
    if value is None:
        return ""
    if isinstance(value, str):
        return value
    return str(value)


def _write_consolidated_text(
    output_path: Path,
    input_path: Path,
    packages: list[dict[str, Any]],
    excluded_names: set[str],
) -> None:
    """Write a single consolidated plain-text notices file."""

    # Formatting: stable ordering helps diff/review.
    packages_sorted = sorted(packages, key=lambda p: _as_text(p.get("Name")).casefold())

    # Header: include provenance and generation timestamp.
    generated_at = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    lines: list[str] = []
    lines.append("THIRD-PARTY SOFTWARE NOTICES AND LICENSES")
    lines.append("")
    lines.append(f"Generated: {generated_at}")
    lines.append(f"Source: {input_path.as_posix()}")
    lines.append("This file is generated. Do not edit by hand.")
    lines.append("")

    # Body: one section per package with full text.
    for pkg in packages_sorted:
        name = _as_text(pkg.get("Name"))
        version = _as_text(pkg.get("Version"))
        license_name = _as_text(pkg.get("License"))
        url = _as_text(pkg.get("URL"))
        license_text = _as_text(pkg.get("LicenseText"))
        notice_text = _as_text(pkg.get("NoticeText"))

        # Filtering: exclude local/project packages (e.g., this repository itself).
        if not _should_include_package(name, excluded_names):
            continue

        lines.append("=" * 80)
        lines.append(f"Package: {name} {version}".rstrip())
        lines.append(f"License: {license_name}".rstrip())
        if url and url != "UNKNOWN":
            lines.append(f"URL: {url}".rstrip())
        lines.append("-" * 80)

        # License: always include a marker even if unknown.
        if license_text and license_text != "UNKNOWN":
            lines.append(license_text.rstrip("\n"))
        else:
            lines.append("LICENSE TEXT: UNKNOWN")

        # NOTICE: include only when present.
        if notice_text and notice_text != "UNKNOWN":
            lines.append("")
            lines.append("NOTICE")
            lines.append("-" * 80)
            lines.append(notice_text.rstrip("\n"))

        lines.append("")

    # IO: ensure output directory exists.
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")


def main() -> None:
    """Entry point."""

    # Args: parse paths.
    args = _parse_args()

    # Normalization: build a case-insensitive exclude set.
    excluded_names = {str(name).strip().casefold() for name in (args.exclude or []) if str(name).strip()}

    # Validate: fail fast for missing input.
    if not args.input.exists():
        raise FileNotFoundError(f"Input JSON not found: {args.input}")

    # Load + write.
    packages = _load_packages(args.input)
    _write_consolidated_text(args.output, args.input, packages, excluded_names)


if __name__ == "__main__":
    main()
