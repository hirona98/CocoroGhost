# 記憶整理（整える）

`（（埋め込みDBから候補取得））` に「似たような項目がたくさん出る」こと自体は、基本的に正常である。
この設計は「候補を広く拾う → LLMが最終選別する」を正としているため、候補段階では重複や近縁が多くなる。

ただし、運用が進むと「状態（`state`）」が増え、近縁項目が過剰に蓄積して検索ノイズになり得る。
そのため **定期的な整理（= 削除ではなく、集約/過去化/要約の育成）** を入れる。

補足:

- 同期/非同期のつながりは `docs/10_実行フロー.md` を参照
- 検索の基本方針は `docs/04_検索（思い出す）.md` を参照

## 非ゴール

- 出来事ログ（`events`）や感情ログ（`event_affects`）の削除
- 完全な重複排除（人間の記憶も似た記憶が並存する）
- 旧DBの移行（運用前なので「作り直し」で対応）

## 「重複」の種類（整理の対象/対象外）

結論:

- **同一IDの重複**: バグ（候補統合で必ず潰す）
- **近い意味の重複**: 仕様上起こりうる（整理で減らす対象）
- **同一スコープの要約の多重**: 仕様上は避けたい（整理で統合する対象）

### 1) 同一IDの重複（バグ）

- 同じ `event_id` / `state_id` / `affect_id` が候補に複数回出るケース
- 原因は「候補収集ソースの統合」や「JOINの重複」など
- 対応は **同期の候補統合で必ず1つにする**

### 2) 近い意味の重複（仕様）

例:

- `events`（出来事本文）と `event_affect`（内心）と `state`（要約/関係）が同じターン由来で似る
- `state.kind` が同じで、似た説明が細かく増える（例: relation が増殖）

この重複は「候補段階」では許容するが、状態が増えすぎると検索が不安定になる。
そのため **非同期で整理して、検索の“足場”を整える**。

## 整理の方針（2レイヤ）

整理は「検索時」と「定期メンテ」で役割を分ける。

### レイヤA: 検索時の重複制御（同期/軽量）

目的:

- 候補を広く拾いつつ、**候補の偏り**を減らして LLM の選別を安定させる

方針（概念）:

- **同一IDの重複は必ず排除**する（同じ行を2回見せない）
- **多様性の予算**を持つ（`SearchPlan.diversify` を尊重する）
  - 例: `type`（event/state/event_affect）ごとの上限
  - 例: `state.kind` ごとの上限
  - 例: `life_stage` / 年バケットごとの上限
  - 例: `thread_key`（文脈）ごとの上限（将来）
- 「近い意味の重複」は、最終的に `SearchResultPack` 側で落とせるので、取りこぼしを優先する

注記:

- 「固有名詞/型番」は n-gram が強いので、ここだけは候補に多めに残してよい

### レイヤB: 定期メンテでの整理（WORKER/品質最優先）

目的:

- “使える状態”を維持して、長期運用で検索ノイズを増やさない
- 「人間っぽい」= 最近性が効きつつ、全期間検索も破綻しない、を両立する

整理対象（正）:

- 更新で育つ状態（`state`）
  - `fact` / `relation` / `task` / `summary` / `long_mood_state`
- 文脈グラフ（`event_threads` / `event_links`）は、必要なら整理対象にしてよい（ただし優先度は state より低い）

整理対象外（正）:

- `events`（出来事ログ）は追記ログとして残す
- `event_affects`（瞬間感情/内心）もイベントの付随ログとして残す

## 状態（state）の整理仕様（提案）

## 現行の実装（最初に入れる整理）

最初に入れる整理は「安全に効く」ものに絞る。

- `state` の **完全一致**（`kind` + `body_text` + `payload_json`）は重複として過去化する
  - ただし `long_mood_state` は整理対象から除外する

注記:

- 「近い意味の統合」は品質難度が高いので、必要になった段階で LLM を使った整理（`TidyPlan`）を導入する
- `long_mood_state` は「単一更新で育てる」を正とし、増殖を防ぐ（整理で消さない）
- （未実装）この設計書で挙げている「統合（merge）」「要約の育成（summary）」「LLMによる `TidyPlan`」は、現状は未実装。

### いつ走らせるか（トリガー）

結論: **chatのターン回数ベース**だけにする（併用しない）。

| パラメータ | 値 | 説明 |
|------------|------|------|
| 初回間隔 | **10ターン** | 動作確認のため短め |
| 通常間隔 | **200ターン** | 運用安定後の値 |
| 1回あたりの最大過去化数 | 200件 | 負荷上限 |
| 取得上限 | 5000件 | アクティブな state の取得上限 |

注記:

- 同期（/api/chat）には入れない（体感速度を守る）
- 実行単位は `embedding_preset_id`（DB単位）
- pending/running の `tidy_memory` ジョブがある場合は二重投入しない

### 何を“整理”するか（やること）

大きく3種類に分ける。

1. **統合（merge）**
   - 近い意味で並存している `state` を「代表1件」に統合して育てる
2. **過去化（close）**
   - 代表以外を `valid_to_ts` で過去化する（削除はしない）
3. **要約の育成（summary）**
   - スコープごとの `state.kind=\"summary\"` を育てて、検索の足場にする

### 近さの判定（候補の作り方）

候補作りは「取りこぼし防止」寄りにしてよい（本判断は LLM 側で品質最優先）。

- 近傍探索（ベクトル）
  - 同一 `kind` の中で近いものを拾う
- 補助条件（軽量）
  - 有効期間の重なり（`valid_from_ts`/`valid_to_ts`）
  - `about_time` の近さ（年/期間）
  - 文脈スレッドの一致（`thread_key`、将来）
  - エンティティの重なり（`entities`、将来）

### 整理の判断（LLMによる計画）

整理は、出来事イベント（`events`）由来ではないので `WritePlan` とは別の入力にする。
ただし、出力は「状態更新（`upsert`/`close`/`mark_done`）」へ落とし込めればよい。

提案: `TidyPlan`（JSONのみ）

```json
{
  "state_updates": [
    {
      "op": "upsert|close|mark_done",
      "state_id": 0,
      "kind": "fact|relation|task|summary|long_mood_state",
      "body_text": "string",
      "payload": {},
      "confidence": 0.0,
      "salience": 0.0,
      "valid_from_ts": "2026-01-10T14:06:59+09:00",
      "valid_to_ts": null,
      "last_confirmed_at": "2026-01-10T14:06:59+09:00",
      "reason": "string",
      "evidence_event_ids": [123]
    }
  ]
}
```

注記:

- 時刻は LLM 入出力では ISO 8601（タイムゾーン付き）文字列を正とする（DB内部はUNIX秒）
- 整理は出来事イベントに直結しない場合があるため、`evidence_event_ids` は空でもよい（監査性を上げたい場合は「統合対象 state が参照していたイベント」を寄せる）

### 適用時の保存ルール

整理は「削除」ではなく「更新で育てる」に寄せる。

- `state` を更新する場合は `revisions` に `before/after/reason` を残す
- 過去化（`close`）も更新なので `revisions` に残す
- 代表を育て、その他を過去化することで「検索は代表に寄る」ようになる

## 感情の整理仕様（提案）

結論: **感情ログ（`event_affects`）は整理しない**。
代わりに、検索時の多様性制御と、長期感情（`long_mood_state`）の育成で“混み合い”を抑える。

- `event_affect` は「その時どう思っていたか」を残すためのログなので、統合しない
- `long_mood_state` は「背景」を表すので、基本は“少数（理想は1件）”に育てる

## 観測（整理が効いているか）

整理は、結果が検索品質に直結するので観測が必要。

- 実行ログ:
  - 対象件数（kind別）
  - 統合数/過去化数/要約更新数
  - 実行時間
- 追跡:
  - `revisions.reason` に「整理」由来であることが分かる文言を入れる
  - （可能なら）どのクラスタを統合したかのメタを `payload` 側に残す
