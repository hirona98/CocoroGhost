# 記憶整理（整える）

`（（埋め込みDBから候補取得））` に「似たような項目がたくさん出る」こと自体は、基本的に正常である。
この設計は「候補を広く拾う → LLMが最終選別する」を正としているため、候補段階では重複や近縁が多くなる。

ただし、運用が進むと「状態（`state`）」が増え、近縁項目が過剰に蓄積して検索ノイズになり得る。
そのため **定期的な整理（= 削除ではなく、過去化）** を入れる。

補足:

- 同期/非同期のつながりは `docs/10_実行フロー.md` を参照
- 検索の基本方針は `docs/04_検索（思い出す）.md` を参照

## 非ゴール

- 出来事ログ（`events`）や感情ログ（`event_affects`）の削除
- 完全な重複排除（人間の記憶も似た記憶が並存する）
- 旧DBの移行（運用前なので「作り直し」で対応）

## 「重複」の種類（整理の対象/対象外）

結論:

- **同一IDの重複**: バグ（候補統合で必ず潰す）
- **近い意味の重複**: 仕様上起こりうる（整理で減らす対象）

### 1) 同一IDの重複（バグ）

- 同じ `event_id` / `state_id` / `affect_id` が候補に複数回出るケース
- 原因は「候補収集ソースの統合」や「JOINの重複」など
- 対応は **同期の候補統合で必ず1つにする**

### 2) 近い意味の重複（仕様）

例:

- `events`（出来事本文）と `event_affect`（内心）と `state`（要約/関係）が同じターン由来で似る
- `state.kind` が同じで、似た説明が細かく増える（例: relation が増殖）

この重複は「候補段階」では許容するが、状態が増えすぎると検索が不安定になる。
そのため **非同期で整理して、検索の“足場”を整える**。

## 整理の方針（2レイヤ）

整理は「検索時」と「定期メンテ」で役割を分ける。

### レイヤA: 検索時の重複制御（同期/軽量）

目的:

- 候補を広く拾いつつ、**候補の偏り**を減らして LLM の選別を安定させる

方針（概念）:

- **同一IDの重複は必ず排除**する（同じ行を2回見せない）
- **多様性の予算**を持つ（`SearchPlan.diversify` を尊重する）
  - 例: `type`（event/state/event_affect）ごとの上限
  - 例: `state.kind` ごとの上限
  - 例: `life_stage` / 年バケットごとの上限
- 「近い意味の重複」は、最終的に `SearchResultPack` 側で落とせるので、取りこぼしを優先する

注記:

- 「固有名詞/型番」は n-gram が強いので、ここだけは候補に多めに残してよい

### レイヤB: 定期メンテでの整理（WORKER/品質最優先）

目的:

- “使える状態”を維持して、長期運用で検索ノイズを増やさない
- 「人間っぽい」= 最近性が効きつつ、全期間検索も破綻しない、を両立する

整理対象（正）:

- 更新で育つ状態（`state`）
  - `fact` / `relation` / `task` / `summary` / `long_mood_state`
- 文脈グラフ（`event_threads` / `event_links`）は、必要なら整理対象にしてよい（ただし優先度は state より低い）

整理対象外（正）:

- `events`（出来事ログ）は追記ログとして残す
- `event_affects`（瞬間感情/内心）もイベントの付随ログとして残す

## 状態（state）の整理仕様（提案）

## 現行の実装（最初に入れる整理）

最初に入れる整理は「安全に効く」ものに絞る。

- `state` の **完全一致**（`kind` + `body_text` + `payload_json`）は重複として過去化する
  - ただし `long_mood_state` は整理対象から除外する

注記:

- 「近い意味の統合」は品質難度が高いので、ここでは扱わない
- `long_mood_state` は「単一更新で育てる」を正とし、増殖を防ぐ（整理で消さない）

### いつ走らせるか（トリガー）

結論: **chatのターン回数ベース**だけにする（併用しない）。

| パラメータ | 値 | 説明 |
|------------|------|------|
| 初回間隔 | **10ターン** | 動作確認のため短め |
| 通常間隔 | **200ターン** | 運用安定後の値 |
| 1回あたりの最大過去化数 | 200件 | 負荷上限 |
| 取得上限 | 5000件 | アクティブな state の取得上限 |

注記:

- 同期（/api/chat）には入れない（体感速度を守る）
- 実行単位は `embedding_preset_id`（DB単位）
- pending/running の `tidy_memory` ジョブがある場合は二重投入しない

### 何を“整理”するか（やること）

結論: **過去化（close）だけ**にする。

- 代表以外を `valid_to_ts` で過去化する（削除はしない）

### 近さの判定

現行は「安全に効く」ものに絞り、完全一致の重複だけを対象にする。

### 整理の判断（計画）

整理は、出来事イベント（`events`）由来ではないので `WritePlan`（ターン由来の更新）とは別に扱う。
ただし現行は「安全に効く」ものに絞り、完全一致の重複を過去化するだけにする。

### 適用時の保存ルール

整理は「削除」ではなく「更新で育てる」に寄せる。

- `state` を更新する場合は `revisions` に `before/after/reason` を残す
- 過去化（`close`）も更新なので `revisions` に残す
- 代表を育て、その他を過去化することで「検索は代表に寄る」ようになる

## 感情の整理仕様（提案）

結論: **感情ログ（`event_affects`）は整理しない**。
代わりに、検索時の多様性制御と、長期感情（`long_mood_state`）の育成で“混み合い”を抑える。

- `event_affect` は「その時どう思っていたか」を残すためのログなので、統合しない
- `long_mood_state` は「背景」を表すので、基本は“少数（理想は1件）”に育てる

## 観測（整理が効いているか）

整理は、結果が検索品質に直結するので観測が必要。

- 実行ログ:
  - 対象件数（kind別）
  - 過去化数
  - 実行時間
- 追跡:
  - `revisions.reason` に「整理」由来であることが分かる文言を入れる
  - （可能なら）どのクラスタを統合したかのメタを `payload` 側に残す
