# 記憶更新（育てる）

返答とは別に、出来事ログから「状態」を育てる。
ここは品質最優先でよい（非同期）。

補足:

- 同期/非同期のジョブの繋がりは `docs/10_実行フロー.md` を参照

## 入力

- 対象の出来事ログ（ターンログ）
  - `user_text` / `assistant_text`
  - 画像付きチャットの場合は `image_summaries_json`（画像要約、内部用）も含める
- 直近の関連状態（必要な範囲）

### `recent_events` と「会話履歴（直近会話）」の違い

結論: **似ているが同一ではない**（目的と形が違う）。

- `recent_events`:
  - **用途**: WritePlan（非同期の記憶更新）で「状態/文脈/感情」を更新するための材料
  - **形**: 1イベント=1要素のスナップショット（`event_id/created_at/source/user_text/assistant_text/...`）
  - **範囲**: 原則「直近12件」。同一 `client_id` を優先し、`source` は `chat` に限らない（通知/観測等も入り得る）
  - **文字数**: 原則として切り詰めない（文脈欠落を避ける）
- 会話履歴（直近会話 / short-term）:
  - **用途**: 返答生成（同期 `/api/chat`）で「口調・直前の合意・流れ」を安定させるための短期コンテキスト
  - **形**: messages 配列（`{"role":"user|assistant","content":"..."}`）
  - **範囲**: `source=="chat"` のみで、設定値 `max_turns_window` 件まで。現在のターンは除外し、`assistant_text` 未確定の途中ターンも除外する
  - **文字数**: 基本は切り詰めず、そのまま送る

補足:

- `chat` 由来の直近部分は、両方が同じDBイベントから作られるため「内容が重なる」ことはある。
- ただし、**対象イベント・切り詰め・形式が違う**ので、入力としては同一視しない。
- つまり「内容は同じ？」への答えは **「重なることはあるが、同じではない」**。

## 出力（更新計画）

- 出来事ログへの注釈（`about_time`、`entities`、話題など）
- 状態（`state`）の更新（`upsert`/`close`/`mark_done` など）
- 変更理由と根拠イベント（必須）

## 更新計画（`WritePlan`）

目的:

- 出来事ログから「状態」「文脈グラフ」「感情」をどう更新するかを決める
- 更新を必ず根拠イベントと紐づけ、改訂履歴（`revisions`）に記録できる形にする

出力例（概略）:

```json
{
  "event_annotations": {
    "about_start_ts": null,
    "about_end_ts": null,
    "about_year_start": null,
    "about_year_end": null,
    "life_stage": "elementary|middle|high|university|work|unknown",
    "about_time_confidence": 0.0,
    "entities": [{"type": "PERSON", "name": "string", "confidence": 0.0}]
  },
  "state_updates": [
    {
      "kind": "fact|relation|task|summary|long_mood_state",
      "op": "upsert|close|mark_done",
      "state_id": null,
      "body_text": "string",
      "payload": {},
      "confidence": 0.0,
      "salience": 0.0,
      "valid_from_ts": "2026-01-10T14:06:59+09:00",
      "valid_to_ts": null,
      "last_confirmed_at": "2026-01-10T14:06:59+09:00",
      "evidence_event_ids": [123],
      "reason": "string"
    }
  ],
  "event_affect": {
    "moment_affect_text": "string",
    "moment_affect_labels": ["string"],
    "moment_affect_score_vad": {"v": 0.0, "a": 0.0, "d": 0.0},
    "moment_affect_confidence": 0.0,
    "inner_thought_text": null
  },
  "context_updates": {
    "threads": [{"thread_key": "string", "confidence": 0.0}],
    "links": [{"to_event_id": 456, "label": "reply_to|same_topic|caused_by|continuation", "confidence": 0.0}]
  }
}
```

注記:

- `*_score_vad.v/a/d` は **-1.0..+1.0** に固定する
- VADの表現は `{"v":...,"a":...,"d":...}` に統一する（`{"vad":{...}}` のような別形式は採用しない）
- 時刻（`valid_from_ts`/`valid_to_ts`/`last_confirmed_at`/`about_*`）は、LLM 入出力では ISO 8601（タイムゾーン付き）文字列を正とする（DB内部はUNIX秒）
- `context_updates` は「文脈グラフを育てる」ための派生更新（不要なら空でもよい）
- 文脈グラフの更新は「同期の仮置き」と「非同期の本更新」に分ける（詳細は `docs/06_ストレージ（SQLite）.md`）
- 出力は「JSONのみ」とする（前後に説明文を付けない）
- 感情テキストの分量目安:
  - `moment_affect_text`: 1〜3文、60〜240文字（「何を見て/何が起きて/どう感じたか」が分かる粒度）
  - `moment_affect_labels`: 0〜6件（短いラベル配列。基本は1〜3件）
  - `inner_thought_text`: 0〜2文、0〜200文字（必要なときだけの内部メモ）
- `event_affect` や `state_updates` の文章には `[face:Joy]` のような会話装飾タグを入れない（会話本文専用）。
- addon（追加プロンプト）は会話本文向けの追加指示とし、WritePlan（内部JSON生成）には注入しない（`moment_affect_text` などの品質を優先する）。
  - 例: 会話の文字数制限、[face:Joy] などの会話装飾タグの説明は addon 側に置く（persona 側に混ぜない）

## 視点（重要）

WritePlan が出す文章は、人格本人の主観で統一する。

- 「アシスタント/ユーザー」などの第三者ラベルで書かない
- 対象: `state_updates.body_text` / `state_updates.reason` / `event_affect.*` / `long_mood_state`（状態本文）

## 更新の原則

- 更新には根拠イベントが必須（`evidence_event_ids` に必ず含める）
- 矛盾がある場合は「上書き」ではなく並存/期間分割を優先する
- 「最近のほうを強く」は、`last_confirmed_at` を更新し検索順位に反映する

補足:

- 出来事イベント（`events`）由来の更新では、根拠イベントは必ず現在の `event_id` を含める
- 定期整理（`docs/11_記憶整理（整える）.md`）のようにイベント直結でない更新では、`evidence_event_ids` が空になる場合がある

## 感情の更新

感情は2系統で更新する（詳細は `docs/09_感情.md`）。

- 長期的な感情（`long_mood_state`）: 会話の進行に応じて更新し、改訂履歴（`revisions`）に残す
- 瞬間的な感情/内心（`event_affect`）: 対象イベントに紐づけて保存する

## 要約（`state.kind="summary"`）の扱い

要約（`state.kind="summary"`）は、現状は **通常の state と同じ扱い**とする。

- `state_updates` により `kind="summary"` が作られる/更新される場合がある
- ただし `payload` に `scope_type/scope_key` を持たせる等のスコープ設計は扱わない
- 「スコープ単位で1件に育てる」「ローリング要約」等は現状は仕様に含めない（必要になったら挙動ベースで追加する）

## 定期的な整理（ノイズを増やさない）

候補収集は「広め」を正とするため、候補段階では似た項目が多くなりやすい。
運用が進むと `state` が増えて検索ノイズになり得るので、**削除ではなく、過去化**として整理を入れる。
詳細は `docs/11_記憶整理（整える）.md`。
