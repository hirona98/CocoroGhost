# 記憶更新（育てる）

返答とは別に、出来事ログから「状態」を育てる。
ここは品質最優先でよい（非同期）。

補足:

- 同期/非同期のジョブの繋がりは `docs/10_実行フロー.md` を参照
- 実装責務は `cocoro_ghost/worker.py`（ジョブスケジューリング）と `cocoro_ghost/worker_handlers.py`（jobs.kind の実処理）で分離している

## 入力

- 対象の出来事ログ（ターンログ）
  - `user_text` / `assistant_text`
  - 画像付きチャットの場合は `image_summaries_json`（画像要約、内部用）も含める
- 直近の関連状態（必要な範囲）

### `recent_events` と「会話履歴（直近会話）」の違い

結論: **似ているが同一ではない**（目的と形が違う）。

- `recent_events`:
  - **用途**: WritePlan（非同期の記憶更新）で「状態/文脈/感情」を更新するための材料
  - **形**: 1イベント=1要素のスナップショット（`event_id/created_at/source/user_text/assistant_text/...`）
  - **範囲**: 原則「直近12件」。同一 `client_id` を優先し、`source` は `chat` に限らない（通知/観測等も入り得る）
  - **文字数**: 原則として切り詰めない（文脈欠落を避ける）
- 会話履歴（直近会話 / short-term）:
  - **用途**: 返答生成（同期 `/api/chat`）で「口調・直前の合意・流れ」を安定させるための短期コンテキスト
  - **形**: messages 配列（`{"role":"user|assistant","content":"..."}`）
  - **範囲**: `source=="chat"` のみで、設定値 `max_turns_window` 件まで（既定: 10）。現在のターンは除外し、`assistant_text` 未確定の途中ターンも除外する
  - **文字数**: 基本は切り詰めず、そのまま送る

補足:

- `chat` 由来の直近部分は、両方が同じDBイベントから作られるため「内容が重なる」ことはある。
- ただし、**対象イベント・切り詰め・形式が違う**ので、入力としては同一視しない。
- つまり「内容は同じ？」への答えは **「重なることはあるが、同じではない」**。

## 出力（更新計画）

- 出来事ログへの注釈（`about_time`、`entities`、話題など）
- 状態（`state`）の更新（`upsert`/`close`/`mark_done` など）
- 変更理由と根拠イベント（必須）

## 更新計画（`WritePlan`）

目的:

- 出来事ログから「状態」「文脈グラフ」「感情」をどう更新するかを決める
- 更新を必ず根拠イベントと紐づけ、改訂履歴（`revisions`）に記録できる形にする

出力例（概略）:

```json
{
  "event_annotations": {
    "about_start_ts": null,
    "about_end_ts": null,
    "about_year_start": null,
    "about_year_end": null,
    "life_stage": "elementary|middle|high|university|work|unknown",
    "about_time_confidence": 0.0,
    "entities": [{"type": "person|org|place|project|tool", "name": "string", "confidence": 0.0}]
  },
  "state_updates": [
    {
      "kind": "fact|relation|task|summary|long_mood_state",
      "op": "upsert|close|mark_done",
      "state_id": null,
      "body_text": "string",
      "entities": [{"type": "person|org|place|project|tool", "name": "string", "confidence": 0.0}],
      "payload": {},
      "confidence": 0.0,
      "valid_from_ts": "2026-01-10T14:06:59",
      "valid_to_ts": null,
      "last_confirmed_at": "2026-01-10T14:06:59",
      "evidence_event_ids": [123],
      "reason": "string"
    }
  ],
  "preference_updates": [
    {
      "op": "upsert_candidate|confirm|revoke",
      "domain": "food|topic|style",
      "polarity": "like|dislike",
      "subject": "string",
      "note": "string (optional)",
      "confidence": 0.0,
      "evidence_event_ids": [123],
      "reason": "string"
    }
  ],
  "event_affect": {
    "moment_affect_text": "string",
    "moment_affect_labels": ["string"],
    "moment_affect_score_vad": {"v": 0.0, "a": 0.0, "d": 0.0},
    "moment_affect_confidence": 0.0
  },
  "context_updates": {
    "threads": [{"thread_key": "string", "confidence": 0.0}],
    "links": [{"to_event_id": 456, "label": "reply_to|same_topic|caused_by|continuation", "confidence": 0.0}]
  }
}
```

注記:

- `*_score_vad.v/a/d` は **-1.0..+1.0** に固定する
- VADの表現は `{"v":...,"a":...,"d":...}` に統一する（`{"vad":{...}}` のような別形式は採用しない）
- 時刻（`valid_from_ts`/`valid_to_ts`/`last_confirmed_at`/`about_*`）は、LLM 入出力では ISO 8601（ローカル時刻、タイムゾーン表記なし）文字列を正とする（DB内部はUNIX秒）
  - タイムゾーン表記が無い日時は「ローカル時刻」とみなしてUTCへ変換する
- `context_updates` は「文脈グラフを育てる」ための派生更新（不要なら空でもよい）
- `state_updates.entities` は「その state に直接関係する entity」だけを入れる（不明なら空でよい）
- 文脈グラフの更新は「同期の仮置き」と「非同期の本更新」に分ける（詳細は `docs/06_ストレージ（SQLite）.md`）
- 出力は「JSONのみ」とする（前後に説明文を付けない）
- `preference_updates` は「ユーザーの好み/苦手」を扱う（性格/習慣は扱わない）
  - `domain`: `food` / `topic` / `style`
  - `polarity`: `like` / `dislike`
  - `op=confirm` は、ユーザーが明示的に好悪を述べた/肯定した場合のみ（推測でconfirmしない）
  - `op=upsert_candidate` は候補（断定の根拠にしない）
  - `op=confirm` で矛盾（同一subjectで like と dislike の両方が confirmed）が見つかった場合は、反対極性を自動で `revoke` する
- 感情テキストの分量目安:
  - `moment_affect_text`: 1〜3文、60〜240文字（「何を見て/何が起きて/どう感じたか」が分かる粒度）
  - `moment_affect_labels`: 0〜6件（短いラベル配列。基本は1〜3件）
- `event_affect` や `state_updates` の文章には `[face:Joy]` のような会話装飾タグを入れない（会話本文専用）。
- addon（追加プロンプト）は会話本文向けの追加指示とし、WritePlan（内部JSON生成）には注入しない（`moment_affect_text` などの品質を優先する）。
  - 例: 会話の文字数制限、[face:Joy] などの会話装飾タグの説明は addon 側に置く（persona 側に混ぜない）

## 視点（重要）

WritePlan が出す文章は、人格本人の主観で統一する。

- 「アシスタント/ユーザー」などの第三者ラベルで書かない
- 対象: `state_updates.body_text` / `state_updates.reason` / `event_affect.*` / `long_mood_state`（状態本文）

## 更新の原則

- 更新には根拠イベントが必須（`evidence_event_ids` に必ず含める）
- 矛盾がある場合は「上書き」ではなく並存/期間分割を優先する
- 「最近のほうを強く」は、`last_confirmed_at` を更新し検索順位に反映する

補足:

- 出来事イベント（`events`）由来の更新では、根拠イベントは必ず現在の `event_id` を含める
- 定期整理（本ファイルの「記憶整理（tidy_memory）」）のようにイベント直結でない更新では、`evidence_event_ids` が空になる場合がある

## 感情の更新

感情は2系統で更新する（詳細は `docs/02_記憶モデル.md` の「感情」を参照）。

- 長期的な感情（`long_mood_state`）: 会話の進行に応じて更新し、改訂履歴（`revisions`）に残す
- 瞬間的な感情（`event_affect`）: 対象イベントに紐づけて保存する

## 要約（`state.kind="summary"`）の扱い

要約（`state.kind="summary"`）は、現状は **通常の state と同じ扱い**とする。

- `state_updates` により `kind="summary"` が作られる/更新される場合がある
- ただし `payload` に `scope_type/scope_key` を持たせる等のスコープ設計は扱わない
- 「スコープ単位で1件に育てる」「ローリング要約」等は現状は仕様に含めない（必要になったら挙動ベースで追加する）

## 定期的な整理（ノイズを増やさない）

候補収集は「広め」を正とするため、候補段階では似た項目が多くなりやすい。
運用が進むと `state` が増えて検索ノイズになり得るので、**削除ではなく、過去化**として整理を入れる。

## 記憶整理（`tidy_memory`）

候補段階で近縁が多いこと自体は正常だが、長期運用で `state` が増えすぎると検索が不安定になる。
そのため、WORKER で定期的に「削除ではなく、過去化（close）」として整理する。

非ゴール:

- 出来事ログ（`events`）や感情ログ（`event_affects`）の削除
- 完全な重複排除（人間の記憶も似た記憶が並存する）

### 現行の整理（最初に入れる安全な整理）

- `state` の **完全一致**（`kind` + `body_text` + `payload_json`）は重複として過去化する
  - ただし `long_mood_state` は整理対象から除外する

注記:

- 「近い意味の統合」は品質難度が高いため、現行は扱わない
- 同期（/api/chat）には入れない（体感速度を守る）

### いつ走らせるか（トリガー）

結論: **chatのターン回数ベース**だけにする。

| パラメータ | 値 | 説明 |
|------------|------|------|
| 初回間隔 | **10ターン** | 動作確認のため短め |
| 通常間隔 | **200ターン** | 運用安定後の値 |
| 1回あたりの最大過去化数 | 200件 | 負荷上限 |
| 取得上限 | 5000件 | アクティブな state の取得上限 |

注記:

- 二重投入はしない（pending/running の `tidy_memory` がある場合は追加しない）

### 観測（整理が効いているか）

整理は検索品質に直結するため、最低限の観測を残す。

- 対象件数（kind別）
- 過去化数
- 実行時間
- `revisions.reason` に「整理」由来であることが分かる文言を入れる
