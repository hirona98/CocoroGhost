# 導入候補まとめ（論文 + AutoMem）: CocoroGhostの記憶強化

作成日: 2026-01-25

参照:

- `docs/15_参考論文_記憶.md`（HippoRAG 2 / A-Mem / ReadAgent）
- `docs/16_参考実装_automem.md`（AutoMemの実装メモ）

このドキュメントは、上記のまとめを統合し、CocoroGhost（AI人格システム）の現行設計に「入れたほうが良さそう」な要素を優先度つきで整理する。

## 前提（CocoroGhostの現行方針）

- 同期 `/api/chat` は体感速度優先（SSE開始前に検索→選別は終えるが、多段の追加呼び出しは避けたい）。
- 記憶は「追記ログ（events）」と「育つ状態（state）」に分ける。
- 状態更新は非同期 `WritePlan` → `apply_write_plan` で行い、更新履歴（`revisions`）を必ず残す。
- 運用前前提: マイグレーション処理/後方互換は入れない（必要ならスキーマやAPIは設計として作り直す）。

## 結論（優先度の高い導入候補）

### A: まず入れるべき（効果が大きく、現行設計と噛み合う）

#### A-1) エンティティ正規化インデックス + エンティティ展開（多段想起）

実装状況:

- 実装済み（2026-01-25）
  - 索引: `event_entities` / `state_entities`（`docs/06_ストレージ（SQLite）.md`）
  - 展開: 同期候補収集に `entity_expand` を追加（`docs/04_検索（思い出す）.md`）
  - `state_entities` は `WritePlan.state_updates[*].entities` を正として付与する（`docs/05_記憶更新（育てる）.md`）

根拠:

- AutoMemの `expand_entities` は「seed → entity → 関連記憶」の多段想起をルールで安定化している。
- CocoroGhostも `WritePlan.event_annotations.entities` を生成しているので、“材料”が既にある。

狙い:

- 「人/組織/場所/プロジェクト/ツール」を軸に、LLM選別前の候補を増やしつつ、取りこぼしを減らす。
- 多段推論をLLMの幻覚に頼らず、「展開ルール」で作る。

設計案（CocoroGhost向け）:

- **正規化キー**: `entity_type_norm + entity_name_norm`
  - `entity_name_norm` は NFKC + 空白整形 + 小文字化で安定化する（英字の揺れ吸収）。
- **保存場所（採用）**:
  - `events.entities_json`（スナップショット）を維持
  - 検索用に「entity ↔ event/state」の参照を持つ（`event_entities` / `state_entities`）
- **同期の候補収集に追加**:
  - seed（最近イベント/候補上位）から entity を抽出
  - entityキーで `events/state` を引いて候補へ追加（`hit_sources=["entity_expand"]`）

注意:

- entityの抽出は誤検出があるので、`confidence`/出現頻度/直近性で足切りする。
- entityの多すぎる展開は候補を肥大化させるため、上限（types別/全体）を設ける。

#### A-2) 展開候補のノイズ抑制（strength/importance/confidenceの“足切り”）

根拠:

- AutoMemは `expand_min_strength` / `expand_min_importance` で「展開だけ」足切りし、seedは守る設計。
- CocoroGhostも候補を広く集める設計なので、ノイズ抑制が無いとLLM選別品質が落ちやすい。

狙い:

- 「広く集める」設計を維持しつつ、LLM選別の入力品質/安定性を上げる。

設計案:

- 候補に `confidence/salience/importance`（概念）を揃えて持たせる。
  - `WritePlan` の `confidence/salience` を将来的にランキングに使えるよう、候補JSONにも入れる。
- “展開枠”だけは閾値を持つ（seed/直近枠は足切りしない）。
  - 例: `min_confidence` / `min_seed_occurrences`（seed内で複数回出たentityだけ展開する）

#### A-3) stateを「ノート」として標準化（A-Mem的な属性を最小セットで持つ）

根拠:

- A-Memの強みは「ノートの属性（context/keywords/tags）＋進化（更新）」。
- CocoroGhostの `state` はまさに“育つノート”なので、属性の標準化は自然。

狙い:

- 検索やLLM選別に渡す情報を整形し、LLMに“何を思い出すべきか”を判断させやすくする。

設計案:

- `state.payload_json` に最低限の標準フィールドを定義する（全kind共通の最小セット）。
  - `keywords: string[]`（短い）
  - `tags: string[]`（短い。将来のフィルタリング用）
  - `context: string`（短い。なぜ重要か/どういう場面か）
- `WritePlan` の出力仕様として、必要な kind（例: `fact/relation/summary`）にだけ付ける（task等はノイズになりやすい）。

---

### B: 次に入れる（実装コストは上がるが、長期運用で効く）

#### B-1) state↔state のリンク（Zettelkasten的リンク / AutoMemの関係展開の土台）

根拠:

- A-Memの「リンク生成」、AutoMemの「graph expansion」に相当。
- CocoroGhostは `event_links/event_threads` が主で、state間の関連づけは薄い。

狙い:

- 「関係の関係」を辿れるようにして、associativity（多段の関連づけ）を上げる。

設計案:

- 非同期ジョブとして「リンク生成」を回す:
  - 近傍候補: ベクトル類似（state）+ 文字n-gram（state本文）
  - 判定: LLMで「リンクする/しない」＋ラベル（`relates_to/derived_from/contradicts/...`）＋強度
  - 保存: state↔state のリンクテーブル（`revisions`と整合）

注意:

- リンク増殖はノイズ/コストになるため、上限・閾値・定期整理の設計が必須。

#### B-2) “メタ記憶”の生成（要約ノードを育て、元を参照リンクする）

根拠:

- AutoMemの `MetaMemory` + `SUMMARIZES`。
- ReadAgentの gist の思想（圧縮表現を先に持つ）。
- CocoroGhostは `state.kind="summary"` があるが、スコープ設計を扱っていない。

狙い:

- 長期運用で `events/state` が増えても、LLM選別入力を“短い中期表現”で支えられるようにする。

設計案:

- “スレッド/話題”単位の summary state を導入する（payloadに `thread_key` 等を入れる）。
- summary state は「最新の合意/変遷」を短く保持し、元イベント/元stateへの参照（リンク）を持つ。

注意:

- summary を“真実”として扱うと誤りが固定化するので、`revisions` と根拠イベントを強制し、必要なら並存させる。

---

### C: 方向性として正しいが、設計コストが高い（段階導入向け）

#### C-1) PPR型のグラフ検索（HippoRAG 2 的な “associativity” を同期候補収集に追加）

根拠:

- HippoRAG 2は PPR + graph（概念↔文脈）で多段の連想を強化している。

狙い:

- 「離れた記憶をつなぐ」探索枠を、ルールで安定して提供する。

導入の現実案:

- いきなりPPRフル実装ではなく、まずは B-1 の stateリンク + A-1 の entity展開 で “多段” の下地を作る。
- その後、PPR相当のランダムウォーク/ランキングを “候補並べ替え” として追加する。

---

## 具体的な導入順（推奨ロードマップ）

1) A-1（entityインデックス+展開） + A-2（展開の足切り）  
2) A-3（stateノート属性の標準化）  
3) B-2（スレッド/話題summaryのメタ記憶化）  
4) B-1（state↔stateリンク生成）  
5) C-1（必要ならPPR型ランキング）

## “入れない”判断（現状方針と衝突するもの）

- 自動削除/forgetting（AutoMemの delete 相当）:
  - CocoroGhostの「忘れない（削除しない）」方針と衝突するため、基本は採用しない。
  - 代わりに「検索対象外（searchable=0）」や「過去化（close）」で扱う。
