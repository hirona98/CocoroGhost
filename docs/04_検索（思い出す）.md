# 検索（思い出す）

検索は「データベースだけで完結」させず、**ルールで計画（RetrievalPlan）を固定**し、**LLMが最終選別**する。
品質最優先（ただし体感速度を壊さない）。

補足:

- 同期/非同期の繋がり（検索→SSE→更新）は `docs/10_実行フロー.md` を参照

## 全体構成（最小で2段）

1. ルール: 検索計画（RetrievalPlan、短いJSON）
2. データベース: 候補収集（広く）
3. LLM: 選別 + 取得結果の整形（検索結果パック: `SearchResultPack`）

必要なら多段にしてよい（例: 追加質問の生成、再検索、時間推定の再実行）。

## 検索計画（`RetrievalPlan` / SearchPlan互換）

目的:

- いまの入力に対して「どう探すか」を明示する（同期待ちを増やさない）
- 並列候補収集のパラメータを固定し、挙動を安定させる

方針:

- LLMでの plan 生成は行わない（毎ターン呼ぶと SSE 開始前の待ちが増えるため）。
- 代わりに、ユーザー入力から **明示された年（4桁）/学生区分など**だけを軽く抽出して plan を作る。
- plan は `retrieval_runs.plan_json` に保存し、観測/デバッグ可能にする。

出力例（概略、キー名は識別子なので英語のまま）:

```json
{
  "mode": "associative_recent|targeted_broad|explicit_about_time",
  "queries": ["string"],
  "time_hint": {
    "about_year_start": null,
    "about_year_end": null,
    "life_stage_hint": "string"
  },
  "diversify": {
    "by": ["life_stage", "about_year_bucket"],
    "per_bucket": 5
  },
  "limits": {
    "max_candidates": 80,
    "max_selected": 12
  }
}
```

キーの意味（概略）:

- `mode`: 検索モード（最近の連想/全期間横断/時間指定）
- `queries`: 文字n-gram向けの検索語（現行は「ユーザー入力そのまま」1件を基本とする）
- `time_hint`: `about_time` と `life_stage` の手がかり
- `diversify`: 偏りを避けるための分散指定（例: `life_stage` ごとに均等に拾う）
- `limits`: 候補数/採用数の上限（主要経路を重くしないため）

### ルール生成の要点（現行）

- `mode` は「明示された年/学生区分などがあるか」で切り替える
  - 年（例: `2018`）が見つかったら `explicit_about_time`
  - `高校/大学/社会人` 等が見つかったら `explicit_about_time`
  - それ以外は `associative_recent`
- `queries` は基本 `["<user_input>"]` のみ（追加クエリ生成はしない）
- `limits.max_candidates` は **TOML（`retrieval_max_candidates`）を基準に強制**する（planが過大にならない）

注記:

- `targeted_broad` は「概念としては残る」が、現行の plan 生成では選ばない（運用で必要になったら設計し直す前提）。
- 期間指定しない「昔話の雑談」を拾うために、別途「ひらめき枠（全期間ベクトル）」を毎ターン少量混ぜる（後述）。

## 検索モード（人間っぽさの分岐）

- 連想モード: 最近性（出来事ログの`created_at`/状態の`last_confirmed_at`）を強く効かせる
- 目的検索モード: 最近性を弱め、`life_stage`/年バケットで分散する
- 時間指定モード: `about_time` を強く使う（高校の頃/2018年 等）

### モード別の動作（実装）

| mode | 最近性の重み | vec(event recent) | vec(event global) | `diversify`（候補分散） | about_time補助 |
|------|------------|------------------|-------------------|------------------------|----------------|
| associative_recent | 高 | 最近90日（常に） | 探索枠（常に少量） | 適用しない（最近性優先） | `time_hint` がある場合のみ |
| targeted_broad | 低 | 最近90日（混ぜる） | 探索枠（混ぜる） | 適用（eventのみ） | `time_hint` がある場合のみ |
| explicit_about_time | 低 | 最近90日（混ぜる） | 探索枠（混ぜる） | 適用（eventのみ） | `time_hint` がある場合のみ |

注記:
- event の vec は **recent と global（探索枠）を分けて回収**し、混入割合は後段の quota（TOML）で制御する。
- `diversify` は、候補統合の直前に「event候補だけ」を並べ替えて、`life_stage`/年バケットの偏りを抑える。
- `associative_recent` の vec recent は `rank_day_range = 今日-90日..今日`（UTC day bucket）で絞る。

## 候補収集（取りこぼし防止優先・並列）

候補は「取りこぼさない」を優先して広く集め、最後にLLMで絞る。
候補収集は、可能なものは **並列**で実行する（体感速度に効く）。
基本は「広め」を正とし、最後の選別（LLM）でノイズを落とす。

- 何でもかんでも検索対象にするとノイズになるため、「検索に効く保存」と「監査/説明用の保存」を分けて扱う
- 候補段階で「似た項目が多い」のは仕様（`events` / `state` / `event_affect` が同じ出来事に由来しやすい）

### タイムアウト仕様

候補収集は並列で走らせ、遅い収集があっても全体が破綻しないようにタイムアウトを設ける。

| 収集ソース | タイムアウト（秒） | 備考 |
|--------------|-------------------|------|
| recent_events | 0.25 | 最近の出来事ログ |
| trigram_events | 0.60 | 文字n-gram検索 |
| reply_chain | 0.20 | reply_toの連鎖 |
| context_threads | 0.35 | 文脈スレッド（event_threads） |
| context_links | 0.35 | 文脈リンク（event_links: same_topic/caused_by/continuation） |
| recent_states | 0.25 | 最近の状態 |
| about_time | 0.40 | 時間ヒント補助 |
| vector | 2.20 | ベクトル検索（recent/global、埋め込みは「入力（+画像要約）」を先行開始） |

タイムアウト時の動作:
- そのソースをスキップして他の結果で続行
- 全ソースがタイムアウトした場合: 空の候補で選別へ進む

### 現状の候補収集（実装済み）

- ベクトル検索（意味）:
  - `events`（recent / global）/ `state` / `event_affects`
  - 同期の体感速度と安定性のため、埋め込み取得は **検索用クエリテキスト**で先行開始し、候補収集（ベクトル検索）で使う
    - 基本: `input_text`
    - 画像付きチャット: `input_text` + 画像要約（空でないもの）
- 文字n-gram検索（表記一致の補助）: `events`（FTS5 trigram）
  - クエリ文字列は `input_text` を正とし、画像付きチャットでは画像要約（空でないもの）も混ぜる
- 最近の出来事: `events.created_at` 降順
- 直前の流れ: `event_links(label="reply_to")` の連鎖
- 文脈グラフ: `event_threads` / `event_links`（`same_topic` / `caused_by` / `continuation`）
  - 同期直後は現在ターンの thread 情報が無いことが多いので、`reply_to` 連鎖を「種」にして辿る
- 最近の状態: `state.last_confirmed_at` 降順
- `about_time` 補助: `plan.time_hint` がある場合のみ、`events.about_year_*` / `life_stage` で追加取得
- **entity展開（多段想起）**: `event_entities/state_entities`（seed→entity→関連候補）
  - 既存候補（seed）に付与された entities から、関連イベント/状態を追加で拾う
  - 混ぜすぎると候補が肥大化するため、TOMLで seed数/展開数/足切りを固定する

## 何を「検索」できるようにするか

結論:

- **出来事ログ（`events`）/状態（`state`）/要約（`state.kind="summary"`）/文脈グラフ/感情**は検索に効く形で参照できるようにする
- **改訂履歴（`revisions`）**は基本は監査/説明用（デバッグ・「なぜ変えた？」）で、通常の会話検索の主要経路には入れない

補足（画像付きチャット）:

- 画像そのものは保存しないが、`events.image_summaries_json`（画像要約）は「検索に効く保存」として扱う
  - 文字検索（FTS）と event 埋め込み（vec_items）の両方に含めるのを正とする

検索パターン別に、効かせる情報は変わる:

- 「最近の連想」: 出来事ログ（`created_at`）+ 状態（`last_confirmed_at`）+ 文脈グラフの辿り
- 「全期間横断」: `about_time`（年/日レンジ） + `life_stage` の分散
- 「固有名詞/型番」: 文字n-gram
- 「あの時どう思ってた？」: `event_affect`（瞬間的な感情/内心）+ 長期の `long_mood_state`
- 「なんの文脈だっけ？」: 文脈グラフ（文脈スレッド/リンク）

## 候補の統合（並列→統合→選別）

- 各候補収集処理は並列に候補を返す（候補には「ソース種別」を付ける）
- その後に重複排除し、候補上限（`retrieval_max_candidates`）の範囲で **経路ごとの割合配分（quota）**を適用して統合する
- 最終的な採用は LLM が行う（`plan.mode` の意図に沿って選別）

注記:

- 同一IDの重複はバグなので必ず排除する
- 「近い意味の重複」は候補段階では許容し、`SearchResultPack` の選別で落とす（取りこぼし防止優先）
- 長期運用で `state` が増えすぎてノイズ化する場合は、非同期で整理（集約/過去化/要約育成）を行う（`docs/11_記憶整理（整える）.md`）

## 候補上限と経路クォータ（高速化と安定化）

目的:

- LLM選別入力の肥大化を防ぎ、SSE開始前の同期待ちを抑える
- trigram / context / vector など「増えやすい経路」が席を独占するのを防ぎ、選別の品質を安定させる

基本は TOML で制御する（`config/setting.toml`）:

- `retrieval_max_candidates`: 候補数上限（最重要）
- `retrieval_event_affect_max_percent`: event_affect が候補を食い過ぎない上限（割合）
- `retrieval_explore_global_vector_percent`: 探索枠（全期間vec(event)）の割合
- `retrieval_quota_*`: mode ごとの割合配分（合計100未満でもOK。余りは元の順位順で埋める）
  - `retrieval_quota_*_entity_only_percent`: entity_expand 単独hitの割合（少量だけ確保）
- `retrieval_entity_expand_*`: entity展開（seed→entity→関連候補）の上限/足切り
  - `retrieval_entity_expand_min_seed_occurrences`: seed内出現回数の足切り（ノイズ抑制）

注記:

- 探索枠（全期間ベクトル）は「期間指定しない昔話の雑談」を拾うための保険で、毎ターン少量だけ混ぜる。
- event_affect は内部用で、候補が増えると state/event を圧迫しやすいので上限キャップのみ持つ。

## 選別入力の圧縮（高速化施策）

SearchResultPack の選別は LLM を使うため、入力 JSON を軽量化して体感速度を改善する。

### candidates の圧縮（単キー化）

- 選別に渡す `candidates` は「プレビュー + メタ」に限定し、本文全文は入れない
- JSONのキーを短くして、文字数（=トークン）を減らす

候補スキーマ（概略）:

- event: `{t:"e", id:<event_id>, ts, src, th:[thread_key], u:<user_preview>, a:<assistant_preview>, img, at:{y0,y1,ls,c}, hs:[source_code]}`
- state: `{t:"s", id:<state_id>, k:<kind>, ts, b:<body_preview>, p:<payload_preview>, vf, vt, hs:[source_code]}`
- event_affect: `{t:"a", id:<affect_id>, eid:<event_id>, ts, ets, m:<moment_preview>, lab, vad, c, hs:[source_code]}`

hit_sources（コード）:

- `re`: recent_events
- `tg`: trigram_events
- `rc`: reply_chain
- `ct`: context_threads
- `cl`: context_links
- `rs`: recent_states
- `at`: about_time
- `vr`: vector_recent
- `vg`: vector_global
- `ex`: entity_expand

### アシスタント本文要約（選別専用の派生情報）

- `events.assistant_text` は長くなりやすいので、非同期で `event_assistant_summaries` に要約を保持する
- 選別入力では、event の `assistant_preview` に **要約（summary_text）**を優先して使う
- 返答生成（会話本文）では **元の events 本文**を使い、要約を“答えの根拠”にしない

観測（ログ）:

- `SearchResultPack selection input prepared candidates=<N> chars=<M>` が出るので、候補数/入力サイズの変化を追える

## 文字検索（再検討メモ）

目的:

- 固有名詞/型番/短い語など、ベクトルだけだと取りこぼしやすいものを拾う

採用案（シンプル優先）:

- SQLite FTS5 の **`trigram`（文字3-gram）** を使う
  - 分かち書きが不要で安定する
  - 実装が軽い（追加依存が少ない）

代替案:

- 形態素解析（MeCab等）で分かち書きしてFTS（精度は上がる可能性があるが運用が重い）
- 文字列LIKE/正規表現（遅くなりやすい）

## 検索結果パック（`SearchResultPack`）

`SearchResultPack` は **検索結果（選別された記憶）** だけを指す。
「現在の文脈（`intent`/`now`/`client_context`）」は別扱いとし、検索結果と混ぜない。

要件:

- ユーザーへ露出しない
- 採用した根拠（なぜ採ったか）をログとして残せる形にする

推奨する中身（概念）:

- 採用項目の一覧（id、種別、短い抜粋）
- 重要なメタ（`created_at` / `last_confirmed_at` / `about_time` / `life_stage`）
- 採用理由（短文）

## 誤想起の自動分離（ベストエフォート）

目的:

- ユーザーから「それは関係ない」「それじゃない」等の否定フィードバックが来たときに、次ターン以降の想起に混ざり続けないようにする

方針（安全寄り）:

- 同期（チャット開始）を遅くしないため、**返答完了後**にバックグラウンドで処理する
- 対象は **直前ターンの `retrieval_runs.selected_json.selected` が1件のときだけ**（曖昧なら何もしない）
- UIや追加質問は行わない（会話のみ）
- 永続・不可逆（後方互換/可逆は扱わない）

分離の定義:

- `events` / `state` は行を残しつつ `searchable=0` にして検索・候補収集・埋め込みから除外する
- `event_affects` は行ごと削除する（内部用であり、再利用価値が低い前提）
