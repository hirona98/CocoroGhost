# 全体像

補足:

- 同期/非同期の具体的な繋がり（シーケンス図）は `docs/10_実行フロー.md` を参照

## コンポーネント

- APIサーバ
  - `/api/chat`（SSE）
  - 画像/通知/リマインダー等の入口（いずれも「出来事ログ」へ落とせる）
- 設定DB（SQLite: `settings.db`）
  - トークン / 各種プリセット / 有効フラグ
- リマインダーDB（SQLite: `reminders.db`）
  - リマインダー状態と発火管理
- 記憶DB（SQLite: `memory_<embedding_preset_id>.db`）
  - 出来事ログ（追記）
  - 状態（更新で育つ、単一テーブル: `state`）
  - 改訂履歴（`revisions`: なぜ変わったか）
  - 検索用インデックス（ベクトル/文字n-gram）
  - 観測ログ（検索計画と採用理由）
  - 感情（長期 + 瞬間 + 内心）
- LLM（LiteLLM経由）
  - 埋め込み（記憶検索用クエリ）
  - 選別と整形（検索結果パック: `SearchResultPack`）
  - 返答（SSE）
  - 記憶更新計画（非同期）
- ルールベース
  - 検索計画（RetrievalPlan、短いJSON。LLMは使わない）

## `/api/chat` の同期フロー（SSE）

体感速度のため SSE は維持するが、ストリーム開始前に「必要な記憶」を確定する。

1. 出来事ログを仮作成し、`event_id` を確保する（ターン単位）
   - 併せて、文脈グラフの**超軽量な仮置き**を行ってよい（例: 直前のイベントへの `reply_to`）
2. ルール: 検索計画（RetrievalPlan）を作る（短いJSON）
3. データベース: 候補を広く集める（ベクトル/文字n-gram/文脈グラフの辿り/時間分散）
4. LLM: 候補を選別し、検索結果パック（`SearchResultPack`）を作る（検索結果だけ）
5. LLM: 返答を SSE で生成する（`SearchResultPack` / `TimeContext` / `LongMoodState` を内部注入）
6. 非同期: 記憶更新（状態更新・履歴・埋め込み・要約）

注記:

 - 3 の候補収集は、可能なものは **並列**で走らせる（ベクトル/文字n-gram/文脈グラフの辿り/時間分散）。

## 非同期フロー（記憶を育てる）

返答のあとで、出来事ログから「何を状態として残すか」を更新する。

- `about_time` 推定（いつの話か）
- エンティティ抽出（人/組織/場所/話題）
- 状態の更新（事実/関係/タスク/要約）
- 改訂履歴（`revisions`）の追記（根拠となった `event_id` を必須にする）
- 検索インデックス更新（ベクトル/文字n-gram）
- 文脈グラフ更新（文脈スレッド/リンクの本更新）
- 感情更新（`long_mood_state` / `event_affect`）

## コード構成（主要モジュール）

- `cocoro_ghost/memory/`: `/api/chat` などの同期フロー（検索→返答→非同期キック）
- `cocoro_ghost/worker.py`: 非同期ジョブ（埋め込み更新/WritePlan適用/整理など）
- `cocoro_ghost/prompt_builders.py`: system/user/internal context のプロンプト組み立て
- `cocoro_ghost/affect.py`: VAD と LongMoodState（baseline+shock）の更新/減衰ロジック
- `cocoro_ghost/common_utils.py`: JSON安定ダンプ、[face:*]除去、LLMのJSON抽出などの共通処理
- `cocoro_ghost/vector_index.py`: vec_items の kind と item_id 生成ルール
