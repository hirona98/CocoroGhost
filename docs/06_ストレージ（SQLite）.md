# ストレージ（SQLite）

## DB境界

- `data/settings.db`
  - トークン / 各種プリセット / 有効フラグ
- `data/reminders.db`
  - リマインダー状態
- `data/memory_<embedding_preset_id>.db`
  - 出来事ログ（`events`）
  - 状態（`facts`/`relations`/`tasks`/`summaries`）
  - 改訂履歴（`revisions`）
  - 検索インデックス（ベクトル/文字n-gram）
  - 観測ログ（`retrieval_runs`）
  - 感情（`long_mood_state` / `event_affect`）

## 方針

- 運用前のため、マイグレーションは扱わない（互換を切って作り直す）
- 埋め込み次元が変わる場合は、`embedding_preset_id` を変えて別DBにする

## テーブル概要（概念）

### `events`（追記ログ）

- 1ターン=1行（user_text + assistant_text）
- `created_at`（記録時刻）と `about_time`（内容の時期）を分けて持つ
- **流れ（文脈）が分かる情報**を持てるようにする

例（概念）:

- `created_at`（記録時刻、UTC）

注記:

- クライアント入力には文脈IDが無い前提でよい
- 文脈参照（文脈スレッド/返信関係）は、**イベント同士の関係を別テーブルとして構築**して、検索・更新で参照できるようにする

### `event_threads` / `event_links`（文脈グラフ）

出来事ログ（`events`）の「流れ」を後から参照するための内部情報。
必要に応じて推定/更新する。

最小の考え方:

- `event_threads`: イベントを「文脈の束」に所属させる（1つのイベントが複数文脈スレッドに属してもよい）
- `event_links`: イベント間の関係（reply_to/continuation/caused_by/same_topic など）を張る

この情報は「検索」と「更新」の両方で使える:

- 検索: 「いまの話題の文脈スレッドを辿る」「似た文脈スレッドを拾う」
- 更新: 「同一文脈の状態更新に寄せる」「矛盾の分離（別スレッド扱い）」など

方針:

- 文脈グラフは **保存して育てる**のを正とする（都度推定だけにしない）
- 理由は、(1) 推定の揺れを減らす、(2) 検索を高速/安定化できる、(3) 「なんの文脈だっけ？」の再現性が上がるため
- ただしこれは派生情報なので、必要なら再構築できる（運用前・移行処理なしの前提でも「作り直し」で対応できる）

更新タイミング（正）:

- **同期（返答前）**: 超軽量な仮置きのみ（LLMは使わない）
  - 例: `reply_to = 直前イベント` を張る
- **非同期（返答後）**: 本更新（LLM可、品質最優先）
  - 文脈スレッドの分割/統合
  - `same_topic/caused_by/continuation` などのリンク追加/修正
  - 確信度（`confidence`）を更新し、根拠イベントを持たせて改訂履歴（`revisions`）に残す

保存時の要件（概念）:

- リンク/文脈スレッドには `confidence` と `created_at` を持つ
- 更新は改訂履歴（`revisions`）に残せるよう、根拠イベント（どの `event_id` からそう判断したか）を持つ

#### 保持方法

文脈グラフは派生情報だが、検索の再現性と速度のために `data/memory_<embedding_preset_id>.db` に保存する。

最低限の保存イメージ:

- `event_links`: `from_event_id` → `to_event_id` の関係（`label` と `confidence` と `created_at`）
- `event_threads`: 「イベントがどの文脈スレッドに属するか」（`thread_key` と `confidence` と `created_at`）

注記:

- 文脈グラフは育つ（分割/統合される）ため、更新は改訂履歴（`revisions`）で追えるようにする

#### 文脈の分離

基本方針は「広めにまとめて、必要なら非同期で分離/統合」。
同期では `reply_to = 直前event_id` の仮置きだけにし、文脈スレッドの分離は非同期の `WritePlan` に任せる。

分離/統合の判断材料（例）:

- 直近の文脈スレッドとの類似（ベクトル/文字n-gram/エンティティ一致）
- 時間ギャップ（長時間の空白）
- 話題転換の明示（「ところで」「別件」など）
- `client_context` の変化（作業/画面の切替など）
- `about_time` の不一致（過去回想に飛んだ等）

### 状態（更新で育つ）

最小セット:

- `facts`
- `relations`
- `tasks`
- `summaries`

共通で持ちたい列:

- `valid_from_ts` / `valid_to_ts`（並存のための有効期間）
- `last_confirmed_at`（最近性）
- `confidence` / `salience`（検索順位に使える）

### 改訂履歴（`revisions`）

- 状態の更新が発生したときだけ追記
- 変更前/変更後のスナップショット + `reason` + `evidence_event_ids`

注記:

- テーブル名は `revisions` とする
- 通常の会話検索は「出来事ログ（`events`）/状態/要約（`summaries`）」を中心にし、`revisions` は「なぜ変えた？」の説明・デバッグに寄せる

### 文字検索（文字n-gram / FTS5 `trigram`）

- `events` を対象にする（表記一致の補助）
- 日本語は分かち書きが不安定になりがちなので、文字n-gram等を使う（例: 文字3-gram）

注記:

- ここはスコア方式の呼称に寄せず、**文字n-gramによる表記一致インデックス**として扱う。
- SQLite の実装としては、FTS5 の `trigram` を使うのが最小で強い。

### ベクトル検索

- `events` と「状態」の両方を対象にする
- ベクトルは「索引」であり本文は別テーブルに持つ

### 感情

- `long_mood_state`: 長期的な感情（状態。文章で保持）
- `event_affect`: 瞬間的な感情/内心（イベントごと。文章で保持）

方針:

- 「後で足す」が難しい前提なので、**文章＋数値の両方**を最初から持てる形にする
- 数値は厳密さよりも「連続的に変化し、検索/制御に使える」ことを優先する
- VAD（快・不快/覚醒/主導）は **-1.0..+1.0** に固定する

## 検索のための索引方針（概念）

「保存したのに検索できない」を避けるため、どの情報をどの索引で拾うかを最初に決める。

- ベクトル索引: 出来事ログ本文、状態本文、要約本文、感情テキスト（`long_mood_text`/`moment_affect_text`/`inner_thought_text`）を対象にできる
- 文字n-gram索引: 出来事ログ本文を対象にする（固有名詞/型番/表記揺れ対策）
- 文脈グラフ: 文脈スレッド/リンクを辿って候補イベントを拾う（検索の加速器）

注記:

- 全項目を主要経路で検索するとノイズとコストが増えるため、`SearchPlan` で「どれを使うか」を切り替える前提にする
- ただし原則は「広め」を正とし、ベクトル/文字n-gram/文脈グラフは基本ONでよい（最後の選別でノイズを落とす）
