# 時間モデル

記憶の「いつ」は1軸では足りない。
この設計では、最低でも次の2軸＋補助軸を使う。

## 1) 最近性

「最近話題に上がった」軸。
無意識の連想では、基本的に最近のものが優先される。

この設計では、最近性は「種類によって別カラム」になる:

- 出来事ログ（`events`）: `created_at`（そのターンが記録された時刻）
- 状態: `last_confirmed_at`（直近で確認/更新された時刻）

補足:

- 出来事ログ（`events`）は必ず `created_at`（記録時刻）を持つ
- 「流れ（なんの文脈だっけ？）」を追うために、内部の文脈グラフ（`event_threads` / `event_links`）を参照できるようにする

## 時刻表現（DBとLLMの役割分担）

結論:

- DB内部: UNIX秒（UTC、整数）を正とする（比較/並び替え/範囲検索が安定する）
- LLM入出力/ログ: ISO 8601（タイムゾーン付き、ローカル時刻）を正とする（読みやすく、LLMも扱いやすい）

注記:

- JSON上のキー名は `created_at` など既存名を使い、値だけを ISO 8601 文字列にする（例: `"created_at": "2026-01-10T14:06:59+09:00"`）

## 2) `about_time`（内容がいつの話か）

出来事の内容が「いつの話か」を推定する。
ユーザー指定（例: 高校の頃、2018年）にも対応する。

### `about_time` はB（両方）

- 日付レンジ（UTC秒）: `about_start_ts`〜`about_end_ts`
- 年レンジ: `about_year_start`〜`about_year_end`
- ライフステージ: `life_stage`

推定には必ず `about_time_confidence` を付ける（断定しない）。

## 3) `life_stage`（全期間横断の分散）

「学校で…」のような検索では、小中高などを同レベルで拾える必要がある。
そのため候補生成時に `life_stage`（や年バケット）で分散させる。
